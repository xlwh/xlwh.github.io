<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Spring Bean的scope]]></title>
      <url>/2018/01/07/Spring-Bean%E7%9A%84scope/</url>
      <content type="html"><![CDATA[<p>scope 描述的是spring容器如何新建Bean实例的。Spring的Scope有以下的几种Scope注解的实现：</p>
<ol>
<li>Singleton:一个Spring容器中只有一个Bean实例，此为Spring的默认配置</li>
<li>Prototype:每次调用，创建一个新的实例</li>
<li>Request: 在web项目中，给每一个http request 新建一个bean实例</li>
<li>Session: 在web项目中，给每一个http session新建一个实例</li>
<li>GlobalSession: 这个只是在portal应用中有用，给每一个global http session 新建一个实例</li>
</ol>
<p>##示例演示<br>（1）编写Singleton的bean</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by zhanghongbin01 on 2017/4/10.</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class DemoSingleService &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)编写Prototype的Bean</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Scope;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by zhanghongbin01 on 2017/4/10.</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public class DemoProtypeService &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）编写配置类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by zhanghongbin01 on 2017/4/10.</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;chapter2&quot;)</span><br><span class="line">public class DiConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）在主函数中启动，进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by zhanghongbin01 on 2017/4/10.</span><br><span class="line"> */</span><br><span class="line">public class TestBeanScopMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(DiConfig.class);</span><br><span class="line">        DemoSingleService single1 = ctx.getBean(DemoSingleService.class);</span><br><span class="line">        DemoSingleService single2 = ctx.getBean(DemoSingleService.class);</span><br><span class="line"></span><br><span class="line">        DemoProtypeService p1 = ctx.getBean(DemoProtypeService.class);</span><br><span class="line">        DemoProtypeService p2 = ctx.getBean(DemoProtypeService.class);</span><br><span class="line"></span><br><span class="line">        //single1 和single2默认使用的是单例模式，在整个的系统中保持的是单例</span><br><span class="line">        System.out.println(&quot;s1和s2是否相等:&quot;+single1.equals(single2));</span><br><span class="line">        //p1和p2使用的是非单例模式，每次都会创建一个新的实例</span><br><span class="line">        System.out.println(&quot;p1和p2是否相等:&quot;+p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果演示"><a href="#结果演示" class="headerlink" title="结果演示"></a>结果演示</h3><p><img src="http://img.blog.csdn.net/20170410083254740?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2l0aHViXzIwMDY2MDA1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
]]></content>
      
        
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[struct timeval结构体]]></title>
      <url>/2018/01/07/struct-timeval%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      <content type="html"><![CDATA[<h1 id="struct-timeval"><a href="#struct-timeval" class="headerlink" title="struct timeval"></a>struct timeval</h1><p>struct timeval是在linux中的一个关于时间的定义，在time.h中进行定义，原型是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct timeval  </span><br><span class="line">&#123;  </span><br><span class="line">__time_t tv_sec;        /* Seconds. */  </span><br><span class="line">__suseconds_t tv_usec;  /* Microseconds. */  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，tv_sec为Epoch到创建struct timeval的秒数，tv_usec为微秒数。使用demo如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])&#123;</span><br><span class="line">    int i;</span><br><span class="line">    struct timeval tv;</span><br><span class="line"></span><br><span class="line">    for(i = 0;i &lt; 10; i++) &#123;</span><br><span class="line">        gettimeofday(&amp;tv, NULL);</span><br><span class="line">        cout &lt;&lt; tv.tv_sec &lt;&lt; &quot; &quot; &lt;&lt; tv.tv_usec &lt;&lt; endl;</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* vim: set ts=4 sw=4 sts=4 tw=100 */</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1510467679 792342</span><br><span class="line">1510467680 792449</span><br><span class="line">1510467681 792503</span><br><span class="line">1510467682 792577</span><br><span class="line">1510467683 792646</span><br><span class="line">1510467684 792691</span><br><span class="line">1510467685 792764</span><br><span class="line">1510467686 792829</span><br><span class="line">1510467687 792896</span><br><span class="line">1510467688 792959</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis介绍]]></title>
      <url>/2018/01/07/redis%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Redis是一个开源的、高性能的、基于键值对的缓冲与存储系统，通过提供多种键值类型来适应不同场景下的存储需求。同时Redis的诸多高级的功能使其可以胜任消息队列、任务队列等不同的角色。</p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>Redis是以字典的形式存储数据，并允许其他应用可以通过TCP协议来访问字典当中的内容。redis字典中的键值处理是字符串以外，还可以使其他的内容，到目前为止，Redis支持的键值数据类型如下：</p>
<ul>
<li>字符串类型</li>
<li>散列类型</li>
<li>列表类型</li>
<li>集合类型</li>
<li>有序集合类型</li>
</ul>
<p>这种字典形式的存储结构与常见的MySQl等关系型数据库的二维表的存储结构有很大的差异。</p>
<h2 id="内存存储与持久化"><a href="#内存存储与持久化" class="headerlink" title="内存存储与持久化"></a>内存存储与持久化</h2><p>Redis将所有的数据存储在内存当中。由于内存的读写速度明显的优与硬盘，因此Redis在性能上比其他基于硬盘的数据库有很大的优势，在一台普通的笔记本电脑上，Redis可以在一秒内读写超过10万个键值。<br>将数据存储在内存中也有问题，比如在程序退出后，内存中的数据全部丢失。不过Redis提供了对数据持久化的支持，即可以把内存中的数据异步写入到内存中，同时不影响对外继续提供服务。</p>
<h2 id="功能丰富"><a href="#功能丰富" class="headerlink" title="功能丰富"></a>功能丰富</h2><p>Redis虽然作为数据库开发的，但是由于它提供了丰富的功能，很多人将Redis用作缓存、队列系统等。<br>Redis可以为每个键值对设置生存时间，生存时间到后会自动清除键值对，这一个特殊的功能可以把Redis用来做缓存系统，在缓存时间过期以后可以自定删除键值对。<br>作为缓存系统，Redis还可以设置最大内存占用空间，当数据的存储到达空间限制以后，可以按照一定的规则自定淘汰不需要的键值对。<br>除此之外，Redis还可以用来实现队列，并且支持阻塞式的读取，可以很容易的实现一个高性能的优先级队列。</p>
]]></content>
      
        
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
